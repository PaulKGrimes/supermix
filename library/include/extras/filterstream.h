// filterstream.h
//
// SuperMix version 1.4 C++ source file
// Copyright (c) 1999, 2001, 2004 California Institute of Technology.
// All rights reserved.
// ********************************************************************
/**
 * @file filterstream.h
 *
 * simple classes which provide for a pretty primitive but useful way
 * to filter characters on their way to or from a stream.
 *
 * @author Frank Rice
 * @date Aug 1, 2001
 *
 */
// ********************************************************************

#ifndef FILTERSTREAM_H
#define FILTERSTREAM_H

#include <iostream>

// ********************************************************************
// class unbuffered_streambuf
//
// This is a template class for unbuffered character transport, derived
// from std::basic_streambuf<charT, traits>.
//
// Derived from Langer and Kreft: "Standard C++ IOStreams and Locales",
// (c) 2000, Addison-Wesley.
// ********************************************************************

template < typename C, typename CT = std::char_traits<C> >
class unbuffered_streambuf : public std::basic_streambuf< C, CT > {
public:
  unbuffered_streambuf() : validBuf(false), takeFromBuf(false) { }

  typedef C char_type;
  typedef CT traits_type;
  typedef typename CT::int_type int_type;


protected:
  // These functions are all redefinitions of functions declared
  // in class streambuf. They are the ones that must be implemented
  // to support unbuffered character transfer:

  // Outputs the provided char (except for EOF). Returns EOF
  // if the character couldn't be output.
  virtual int_type overflow(int_type c = traits_type::eof());

  // Inputs and consumes a char. Result comes from
  // charBuf if it holds an unconsumed char. Any raw
  // input from device is copied to charBuf. Returns
  // EOF if unable to get a char.
  virtual int_type uflow();

  // Inputs but doesn't consume a char. Result comes
  // from charBuf if it holds an unconsumed char. Any raw
  // input from device is copied to charBuf. Returns
  // EOF if unable to get a char.
  virtual int_type underflow();

  // Puts the supplied char back into charBuf, if it doesn't
  // contain an unconsumed char. If c == EOF, then makes any
  // consumed but valid char in charBuf available again. Fails
  // otherwise.
  virtual int_type pbackfail(int_type c);


  // These functions implement character transfer to the external
  // device with which a stream communicates:

  // This function should return true if its char is successfully
  // written to the output. The default writes to cout.
  virtual bool char_out(char_type c);

  // This function should return true if its char is successfully
  // read from the input. The default reads from cin.
  virtual bool char_in (char_type & c);

  // these member variables are only used for char input
  char_type charBuf; // holds last char read from input
  bool validBuf;     // true if charBuf has a valid char.
  bool takeFromBuf;  // true if next read should be from charBuf.
  // takeFromBuf == true -> validBuf == true;
  // validBuf == false -> takeFromBuf == false.
};


// ********************************************************************
// class basic_ofilterstream<charT, traits>
// typedef ofilterstream => basic_ofilterstream<char>
//
// Filter characters on output and pass on to another basic_ostream.
//
// This class is designed to accept characters for output just as any
// other output stream. The class forwards the characters along to
// some other basic_ostream using a filter function which may transform
// the character stream in some fashion.
//
// Although not an abstract class, it is meant to be used as a base
// class. Derived classes should redefine the member function filter()
// so that it does something useful.
//
// Here's how it works (I'll use class ofilterstream, which is a char-
// based instantiation of basic_ofilterstream<> for this example):
//
// You declare an ofilterstream object by including the stream you want
// to send the output to in its declaration:
//   ofilterstream f(cout);  // output eventually goes to cout
//
// Now send output to the ofilterstream just as you would to the
// underlying output stream:
//   f << "Hi " << "there. " << 1.0 << endl;
//
// The ofilterstream contains an unbuffered_streambuf which is used to
// receive the characters generated by operator <<(). the streambuf
// calls the ofilterstream filter() member function to send these
// characters on to the underlying ostream (cout in this example).
// The filter() member function may examine each character it receives
// and in turn determine what characters should be passed on - for
// example, it could change each character to uppercase or could 
// ignore blank lines. filter() sends a character on to the underlying
// output stream by calling ofilterstream's member function char_out().
//
// There is an additional stream manipulator defined for use with
// basic_ofilterstream: changestream. You use it to change the target
// stream of the filter as in:
//   f << changestream(cerr);
//
// See extras/commentstream.h for an example of a class derived from
// ofilterstream.   
//
// ********************************************************************
template < typename C, typename CT = std::char_traits<C> >
class basic_ofilterstream : public std::basic_ostream<C,CT> {
public:

  typedef C char_type;
  typedef CT traits_type;
  typedef typename CT::int_type int_type;

  // The constructor argument is the basic_ostream to which the filtered
  // characters are forwarded.
  basic_ofilterstream(std::basic_ostream<C,CT> & s);
  virtual ~basic_ofilterstream()  { }

  // Change the assigned output basic_ostream. Returns the previously
  // assigned target stream.
  std::basic_ostream<C,CT> & stream(std::basic_ostream<C,CT> & s)
  { std::basic_ostream<C,CT> & temp = *ps; sync_ps(); ps = &s; return temp; }

  // Just report the current target stream.
  std::basic_ostream<C,CT> & stream() const { return *ps; }

protected:
  // Redefine this fcn in a derived class to do something useful
  // it should return false if something went wrong.
  virtual bool filter(char_type c)  { return char_out(c); } 

  // This points to the stream where the filtered output goes.
  std::basic_ostream<C,CT> *ps;

  // filter() should use this function to forward characters
  // to the output stream. Returns false if the output
  // basic_ostream has a problem.
  bool char_out(char_type c)  { return ps->put(c); }

  // This one is called by ofilterbuffer buf whenever it is
  // asked to sync() itself. It may be redefined in a derived
  // class. Any redefined version probably should call
  // sync_ps() at some point. 
  virtual int sync() { return sync_ps(); }

  // Flush the buffer of the real output stream.
  int sync_ps() { ps->flush(); return(*ps) ? 0 : -1; }

private:
  // Class ofilterbuffer is an unbuffered_streambuf with
  // a redefined char_out() and sync(). They call
  // basic_ofilterstream's filter() and sync(),

  struct ofilterbuffer : public unbuffered_streambuf<C,CT> {
    ofilterbuffer(basic_ofilterstream<C,CT> & parent) : s(parent) { }
    bool char_out(C c)  { return s.filter(c); }
    int sync() { return s.sync(); }
    basic_ofilterstream<C,CT> & s;
  };
  friend class basic_ofilterstream::ofilterbuffer;

  // Here's the buffer we use:
  ofilterbuffer buf;
      
}; // end basic_ofilterstream


// ******************************************************************
// This templated version of << should ensure that 
// concatenated << operators still see a basic_ofilterstream and not
// simply a basic_ostream:

template < typename C, typename CT, typename T >
inline basic_ofilterstream<C,CT> & 
operator << (basic_ofilterstream<C,CT> & fs, T arg)
{ *(static_cast<std::basic_ostream<C,CT>* >(&fs)) << arg; return fs; }


// ******************************************************************
// The following code defines a manipulator and a << operator
// to change the target stream of a filter. It is used like
// this (where fs is a filter stream and s is the new target
// stream): fs << changestream(s);

namespace internals {
  template < typename C, typename CT >
  struct filterstreamchanger {
    std::basic_ostream<C,CT> * ps;
    filterstreamchanger(std::basic_ostream<C,CT> & s) : ps(&s) { }
    void changestream(basic_ofilterstream<C,CT> & fs)
    { fs.stream(*ps); }
  };
}

template < typename C, typename CT >
inline internals::filterstreamchanger<C,CT>
changestream(std::basic_ostream<C,CT> & s)
{ return internals::filterstreamchanger<C,CT>(s); }

template < typename C, typename CT >
inline basic_ofilterstream<C,CT> & 
operator << (basic_ofilterstream<C,CT> & fs,
	     internals::filterstreamchanger<C,CT> f)
{ f.changestream(fs); return fs; }

// ******************************************************************
// class unbuffered_streambuf member definitions

template < typename C, typename CT >
typename unbuffered_streambuf<C,CT>::int_type 
unbuffered_streambuf<C,CT>::overflow
(typename unbuffered_streambuf<C,CT>::int_type c)
{
  if (!traits_type::eq_int_type(c,traits_type::eof())) 
    return (char_out(c)) ? c : traits_type::eof();
  else
    return traits_type::not_eof(c);  // return something != EOF
}

template < typename C, typename CT >
typename unbuffered_streambuf<C,CT>::int_type 
unbuffered_streambuf<C,CT>::uflow()
{
  if(takeFromBuf) {
    takeFromBuf = false;
    return traits_type::to_int_type(charBuf);
  }
  else 
    return ((validBuf = char_in(charBuf))) ?
      traits_type::to_int_type(charBuf) : traits_type::eof();
}

template < typename C, typename CT >
typename unbuffered_streambuf<C,CT>::int_type 
unbuffered_streambuf<C,CT>::underflow()
{
  if(takeFromBuf)
    return traits_type::to_int_type(charBuf);
  else 
    return ((takeFromBuf = validBuf = char_in(charBuf))) ?
      traits_type::to_int_type(charBuf) : traits_type::eof();
}

template < typename C, typename CT >
typename unbuffered_streambuf<C,CT>::int_type 
unbuffered_streambuf<C,CT>::pbackfail
(typename unbuffered_streambuf<C,CT>::int_type c)
{
  if(!takeFromBuf) {
    if(!traits_type::eq_int_type(c,traits_type::eof())) {
      charBuf = traits_type::to_char_type(c);
      validBuf = takeFromBuf = true;
      return traits_type::to_int_type(charBuf);
    }
    else if(validBuf) {
      takeFromBuf = true;
      return traits_type::to_int_type(charBuf);
    }
    else
      return traits_type::eof();
  }
  else
    return traits_type::eof();
}

template < typename C, typename CT >
bool unbuffered_streambuf<C,CT>::char_out
(typename unbuffered_streambuf<C,CT>::char_type c)
{ return (std::cout << c).good(); }

template < typename C, typename CT >
bool unbuffered_streambuf<C,CT>::char_in 
(typename unbuffered_streambuf<C,CT>::char_type & c)
{ return (std::cin >> c).good(); }


// ******************************************************************
// class basic_ofilterstream member definitions

template < typename C, typename CT >
basic_ofilterstream<C,CT>::basic_ofilterstream(std::basic_ostream<C,CT> & s)
  : std::basic_ostream<C,CT>(&(this->buf)), ps(&s), buf(*this) { }


// ******************************************************************
// typedef for ofilterstream of char's

typedef basic_ofilterstream<char> ofilterstream;

#endif /* FILTERSTREAM_H */
