// makeikk.cc
//
// A simple program to generate the Kramers-Kronig transform of an SIS
// DC IV curve input from a file, such as generated by fakeiv.cc.
// Here's what it does:
//   (1) Read in the DC IV data points from a file.
//   (2) Generate an evenly-spaced set of a couple-thousand DC IV points
//       using a cubic spline interpolation of the supplied data points.
//       These points cover V = 0 to V = Vrange, which by default is
//       twice the maximum voltage in the supplied DC IV set.
//   (3) Calculate the K-K transforms of these interpolated points.
//   (4) Adaptively fill another cubic spline interpolator so that it
//       accurately reproduces the calculated K-K transform but with far
//       fewer data points.
//   (5) Output the V-I pairs used in the interpolator generated in (4).
//
// Not very pretty, but it works.
//
// The resulting output is sent to the program's standard output
// stream; you can redirect this output into a file so that you can
// use this file along with the original DC IV data file as inputs for
// the SuperMix "ivcurve" class (see supermix/include/junction.h).
// 
// The program calculates the K-K transform of the DC IV curve by
// performing an analytic integration of the DC IV data set (2),
// using a piecewise-linear interpolation between points for the
// integrand.
//
// An input file name must be included on the command line. Type the
// program name with no arguments to get a usage prompt.
//
// The program will generate an occasional status output to its
// standard error stream, prefixed by a comment symbol ("#" by
// default).
//
// ---------------------------------------------------------------------------

#include "supermix.h"
#include "numerical.h"

// ---------------------------------------------------------------------------
// Function to print a usage prompt, with definitions of the
// parameters

void prompt(const char *const *const argv);

// ---------------------------------------------------------------------------
// Global parameters set by command line which control the Ikk
// generation

const char *name;             // SIS DC IV data file name
double Vrange = 0.0;          // voltage domain is (0 - Vrange)
int    npoints = 2000;        // number of points to calculate
double Vstep;                 // voltage interval between points

const char *comment = "#";    // comment prefix character for output

// ---------------------------------------------------------------------------
// These data structures will be used to generate the results

std::vector<double> Iv; // a many-point interpolation of SIS IV data
interpolation Ikk_raw;  // the brute-force K-K results
interpolation Ikk_f;    // the final interpolator whose points will be output

// See the comments in fakeiv.cc for an introduction to interpolators
// and how to adaptively fill them with data points to achieve a
// desired accuracy.

// ---------------------------------------------------------------------------
// We'll use this class to perform the analytic calculations
struct calc_type {

  // Calculated info about the supplied IV data:
  double   M_inf; // the slope from Iv[npoints] to Infinity (ie, 1/Rn)
  double   B_inf; // the intercept for the line from Iv[npoints] to Infinity

  // call this function after filling the Iv vector and before using
  // calc functions.  It calculates values for M_inf and B_inf
  void setup();

  // Here's what we need to do to use calc_type to calculate a K-K
  // transform value: The integral we are performing is:
  //
  //   Ikk(x) =
  //   (1/Pi) * Integral(0->Infinity)(I(v)*(1/(v-x)+1/(v+x)-2/v)*d(v))
  //
  // where we take the Cauchy Principal Value of the integral.
  //
  // We break the integral up into small voltage intervals over which
  // we take Iv(v) to be linear in the voltage v. We can perform the
  // integration over each such interval. By summing the results of
  // these integrations, we get the K-K transform value for a
  // particular voltage x.
  //
  // The various member functions below perform the integrations over
  // the various intervals. We loop over all intervals in main(),
  // summing the results of the function calls.

  // calculate a term of the Ikk sum for interval from V[k] to V[k+1],
  // where the voltage x of the transform is V[i]. We must have 0 < k
  // < npoints, and k != i and k+1 != i. This is an analytic
  // integration over the interval
  double calc(int k, int i);

  // calculate the term for 0 to V[1], i != 1.
  double calc1(int i);

  // calculate terms from V[npoints] to Infinity
  double calcN(int i);

  // calculate a special term if x == V[1], covering k = 0 to k = 2
  double specialV1();

  // calculate special term for x == V[j] , j > 1, covering k = j-1
  // to k = j+1 or Infinity (if j = npoints)
  double specialVJ(int j);

} calc;


// ---------------------------------------------------------------------------
int main(int argc, char **argv) 
{
  // process command line
  bool bad_param = false;
  switch(argc) {
  default: { bad_param = true; break; }
  case 4: Vrange = atof(argv[3]);  // if 3 args, last is new Vrange. Fall thru
  case 3: npoints = atoi(argv[2]); // if present, 2nd arg is npoints. Fall thru
  case 2: name = argv[1];          // 1st arg is always input Idc file name
  }

  if (Vrange < 0.0 || npoints < 2) bad_param = true;

  if (bad_param) {
    prompt(argv);
    return 1;
  }

  real_interp Idc;                  // an interpolator of the SIS DC IV data
  cerr << comment << " Reading in DC IV data..." << endl;
  Idc.file(name).quiet().build();
  cerr << comment << " ... done." << endl;
  if(!Idc.ready()) return 1;
  

  // Here we calculate the desired K-K tranform output voltage range
  // and the voltage interval between points in our brute-force K-K
  // calculations.
  if (Vrange == 0.0) Vrange = 2*Idc.x(Idc.size()-1); // twice the max DC IV voltage
  Vstep = Vrange/(npoints-1);
  

  // Build the vector of I(V) for our Idc data. IV points will number
  // in range 0 .. npoints.  Voltage range will be 0.0 .. Vrange+Vstep
  cerr << comment << " Interpolating " << npoints << " DC IV points..." << endl;
  Iv.push_back(0.0);  // Iv(v=0.0) == 0.0
  for (int j = 1; j <= npoints; ++j)
    Iv.push_back(Idc(j*Vstep));
  cerr << comment << " ... done." << endl;

  

  // Now for the brute-force calculations
  calc.setup();
  Ikk_raw.add(0.0,0.0); // Our K-K transform goes thru (0,0)

  cerr << comment << " Calculating transform..." << endl;
  // There will be a total of about npoints*npoints loop iterations...
  for (int i = 1; i <= npoints; ++i) {

    if (i%500 == 0)
      cerr << comment << " ... " << i << " points." << endl;
    double Ikk = 0.0;
    int j;  // loop index for integration

    if (i==1) {
      Ikk += calc.specialV1();
      j = 2;
    }
    else {
      Ikk += calc.calc1(i);
      j = 1;
    }

    for( ; j < npoints; ++j) {
      if(j+1 == i)
	Ikk += calc.specialVJ(++j);  // ++j since this fcn covers 2 intervals
      else
	Ikk += calc.calc(j,i);
    }
    // at loop exit, j == npoints normally, but j == npoints+1 if i == npoints
    if (j == npoints) Ikk += calc.calcN(i);
    
    // Finally divide by Pi to get the final Ikk value, and add to Ikk_raw
    Ikk /= Pi;
    Ikk_raw.add(i*Vstep, Ikk);
  }

  // Now build the raw interpolator. See fakeiv.cc for a description of
  // interpolators.
  cerr << comment << " Building an interpolator of the " << npoints << " points..." << endl;
  Ikk_raw.left_slope(0.0).spline().build();
  cerr << comment << " ... done." << endl;

  // Adaptively fill the final interpolator by comparing to Ikk_raw
  // Play with the absolute and relative error tolerances if you wish
  cerr << comment << " Adaptively building final interpolator..." << endl;
  Ikk_f.spline().left_slope(0.0).right_slope(Ikk_raw.prime(Vrange));
  adaptive_fill(Ikk_f, Ikk_raw, 0, Vrange, .0001, .001); // abs error, rel error
  cerr << comment << " ... done. Total number of points to output: " 
       << Ikk_f.size() << endl;
  cerr << comment << " Outputting V-I pairs." << endl;

  // Print a header
  cout << fixed << setprecision(6);
  cout << comment << " Kramers-Kronig Transform of IV characteristic curve" << endl;
  cout << comment << endl;
  cout << comment << " The DC IV file for this data:  " << name << endl;
  cout << comment << " Info calculated from this file:  " << endl;
  cout << comment << "    Rn:      " << 1/calc.M_inf << endl;
  cout << comment << "    Offset:  " << calc.B_inf << endl;
  cout << comment << endl;
  cout << comment << " Number of internally-generated points:  " << npoints << endl
       << comment << " Max Voltage in output V-I data:   " << Vrange << endl;
  cout << comment << endl;
  cout << comment << " Command line:" << endl
       << comment;
  for (int j = 0; j < argc; ++j) (cout << " " << argv[j]);
  cout << endl << comment << endl;
  cout << comment << " V:                 " << "\t" << "I:" << endl;
  cout << fixed << setprecision(18);

  // Now output the (V,I) points in the interpolator.
  for(unsigned i = 0; i < Ikk_f.size(); ++i)
    cout << Ikk_f.x(i) << "\t" << Ikk_f[i] << endl;

  return 0;
}

// ---------------------------------------------------------------------------
// Definition of prompt()
void prompt(const char *const *const argv)
{
  cerr << argv[0] << ": calculate the Kramers-Kronig transform of a SIS DC IV"
       << endl << "curve for use with SuperMix." << endl << endl;
  cerr << "Usage: " << argv[0] << " <idc_file>"
       << " <npoints(2000)> <Vrange(2 * Vmax)>" << endl;
  cerr << "Where (default values are in () after argument name):" << endl
       << " idc_file:          name of Idc data file" << endl
       << " npoints(optional): number of Ikk values to internally generate"
       << endl
       << " Vrange (optional): output voltage points from 0 to <Vrange>" << endl
       << endl
       << "Vmax is the max voltage value in the Idc data file." << endl
       << "Way fewer points than npoints will actually be output." << endl
       << "Accuracy improves by increasing npoints, but execution time" << endl
       << "scales as npoints*npoints." << endl;
}

// ---------------------------------------------------------------------------
// Definitions for calc_type

void calc_type::setup()
{
  // Slope at the end of the Iv data (remember, voltage interval between points
  // is Vstep)
  M_inf = (Iv[npoints]-Iv[npoints-1])/Vstep;
  B_inf = Iv[npoints] - (M_inf * npoints * Vstep); 
}

double calc_type::calc(int k, int i)
{
  double x    = i*Vstep;
  double Vk   = k*Vstep,   Ik   = Iv[k];
  double Vkp1 = Vk+Vstep,  Ikp1 = Iv[k+1];
  double Xk   = x/Vk, Xkp1 = x/Vkp1;            // convenient ratios

  double MX = x*(Ikp1 - Ik)/(Vkp1 - Vk);        // m*x, m = linear slope
  double B  = (Ik*Vkp1 - Ikp1*Vk)/(Vkp1 - Vk);  // x==0 intercept of line

  double result  = (MX-B)*log(fabs((1+Xk)/(1+Xkp1)));
  result -= (MX+B)*log(fabs((1-Xk)/(1-Xkp1)));

  return result;
}

double calc_type::calc1(int i)
{
  double x  = i*Vstep;
  double V1 = Vstep, I1 = Iv[1];
  double X  = x/V1;
  double MX = x*(I1/V1);   // intercept == 0.0 for this interval

  return MX*log(fabs((1-X)/(1+X)));
}

double calc_type::calcN(int i)
{
  double x  = i*Vstep;
  double VN = npoints*Vstep;
  double X  = x/VN;
  double MX = x*M_inf;
  
  return (MX-B_inf)*log(fabs(1+X)) - (MX+B_inf)*log(fabs(1-X));
}

double calc_type::specialV1()
{
  double V1 = Vstep,   I1 = Iv[1];
  double V2 = 2*Vstep, I2 = Iv[2];
  double X  = V1/V2;

  double MX = V1*(I2 - I1)/(V2 - V1);  // MX between V[1] and V[2]
  double B  = I1 - MX;                 // B  between V[1] and V[2]

  return I1*log((1-X)/2) + (MX-B)*log(2/(1+X)) ;
}

double calc_type::specialVJ(int j)
{
  // first look at interval from j-1 to j
  double Vjm1 = Vstep*(j-1), Ijm1 = Iv[j-1];  // these are Vj-1, Ij-1
  double Vj   = Vstep*(j),   Ij = Iv[j];

  double MX_low = Vj*(Ij - Ijm1)/(Vj - Vjm1);
  double B_low  = (Ijm1*Vj - Ij*Vjm1)/(Vj - Vjm1);
  double X_low  = Vj/Vjm1;

  // Now for the interval starting at j, which may be npoints...
  double Vjp1, Ijp1, MX_hi, B_hi, X_hi; 
  if(j < npoints) {
    // Vj+1 exists in the data
    Vjp1  = Vstep*(j+1); Ijp1 = Iv[j+1];
    MX_hi = Vj*(Ijp1 - Ij)/(Vjp1 - Vj);
    B_hi  = (Ij*Vjp1 - Ijp1*Vj)/(Vjp1 - Vj);
    X_hi  = Vj/Vjp1;
  }
  else {
    // Vj == npoints
    MX_hi = Vj*M_inf;
    B_hi  = B_inf;
    X_hi  = 0;                 // VN/Infinity
  }

  // Calculate the result
  double result  = Ij*log((1-X_hi)/(X_low-1));
  result += (MX_low-B_low)*log((1+X_low)/2);
  result += (MX_hi-B_hi)*log(2/(1+X_hi));
  return result;
}
