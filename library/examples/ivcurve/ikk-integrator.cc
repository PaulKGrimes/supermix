// ikk-integrator.cc
// A program to generate the Kramers-Kronig transform of a normalized
// SIS DC IV curve, such as generated by fakeiv.cc. It gives good
// results most of the time; Examine a plot of the output to ensure
// that there are no discontinuities introduced by numerical
// artifacts.
//
// An input file name must be included on the command line;
// the output will be written to the standard output stream.

#include "supermix.h"

// integrators and adaptive interpolation building are not included by
// supermix.h, so we must load in the special numerical headers as
// well.
#include "numerical.h"

// The comment prefix string to be used in the output header:
const char *comment = "#";

// ---------------------------------------------------------------------------
// Some parameters you can adjust to control the integration (see integrate.h):

unsigned   ORDER   = 3;        // the order of the Rhomberg extrapolation (min 1)
double     ABS_TOL = 1.0e-9;   // absolute error tolerance
double     REL_TOL = 1.0e-10;  // relative error tolerance
double     FACTOR  = 1.0/Pi;   // Vo*FACTOR is where we change integration method

// Lowering the tolerances to ~ 1.0e-7 may generate the results more
// quickly, but will only work well if the DC IV curve is not very
// sharp at the gap. Lowering ORDER to 1 may help, but often will not.
// If you run into convergence problems, this condition will usually
// be indicated by an error message like "WARNING: Recursion limit
// reached in adaptive interpolator build."  Changing FACTOR slightly
// (eg: FACTOR = 1.01/Pi) is often sufficient to resolve convergence
// problems. If you get the WARNING message mentioned above, make sure
// that you carefully examine the output, as there may be an obviously
// wrong value generated which sits slightly away from where it should
// be. This is indicated by a large number of output points very close
// to and on either side of the wrong point. If the input IV curve is
// very sharp, the output may be just fine, even though the warning
// was generated. It may be better to use the more robust method of
// makeikk.cc to generate your Kramers-Kronig transform in this case.

// ---------------------------------------------------------------------------
// Here are the global variables and functions we use to generate the
// transform: real_interp (defined in real_interp.h) is just an
// interpolator<double> with some useful additional capabilities, like
// loading its data from a file.  See fakeiv.cc for an introduction to
// interpolators.

real_interp IDC;  // will interpolate the normalized DC IV file data 
double Vo;        // will hold the maximum voltage point in IDC table


// The next function properly extends the interpolated DC IV data to V
// < 0.  Therefore we can use IDC to get idc(v) for all v. Note how we
// ask the interpolator object for an interpolated value: we simply
// use it like a function which takes a single argument of type
// double, so IDC(v) returns the interpolated current at the voltage
// v.

double idc(double v) { return (v < 0.0) ? -IDC(-v) : IDC(v); }


// Now we define the integrand for the Kramers-Kronig calculation.
// This "function" F is really just a type name for a generalized
// "function object", or functional, which has the function operator
// () defined on it.  Once we create an object of type F we can use it
// just like any traditional function by appending an argument
// surrounded by parentheses.  This is like the interpolator object
// IDC, which is also a functional.

struct F {
  double x;
  F(double xx): x(xx) { }  // supply an initial value for x in the constructor 

  // here's the definition of the () operator which allows F objects
  // to mimic the behavior of a function:
  double operator()(double v) const
  { 
    if (x < ABS_TOL || v < ABS_TOL) return 0.0;
    else return (idc(v+x)+idc(v-x)-2.0*idc(v))/v; 
  }
};

// Note: a struct is just a class with all members defaulting to
// public accessibility.


// The Kramers-Kronig transform requires a Cauchy Principal Value
// integration of the operand defined by the functional type F. Here's
// where we perform that operation.
//
// First we need an integrator object. Intergrators are objects of a
// templated class defined in integrate.h. When we declare an
// integrator we must supply a template argument which identifies the
// type of the integrand. The variable of integration is always of
// type double. Integrator objects are functionals whose argument list
// will include the integrand and limits of integration.
 
integrator<double> In;  // In is an integrator object which returns a double.


// The following function uses the integrator to calculate the
// Kramers-Kronig transform of a voltage x.

double ikk_f(double x)
{
  F f(x);
  return (In.open()(f, 0, Vo/Pi)
	  + In.exp()(f, Vo/Pi, 1000)
	  )/Pi;
}

// Note a couple of interesting things about the above definition
// which show the power of the C++ functional concept:
//
// The integrator member functions open() and exp() simply set the
// method used to calculate the integral; they return the integrator
// object itself, so "In.open()(...)" works just like calling
// "In(...)".
//
// About the "f" in the argument list to the integrator call: "F f(x)"
// constructs an object of type F, which is passed as an argument to
// the integrator.  The integrator will call this argument using
// operator (), executing the command "f(v)", returning:
// (idc(v+x)+idc(v-x)-2.0*idc(v))/v.
//
// Now we see why we needed the functional F rather than a traditional
// function.  The integrator only expects integrands which are
// functions of the single variable of integration; By creating an
// object of type F we can pass the 2nd variable x as a parameter at
// construction, and the integrator doesn't notice.
//
// Finally, "Pi" is a constant defined in global.h.


// ---------------------------------------------------------------------------
// the main routine:

int main(int argc, char **argv) 
{
  // Check that a filename was included on the command line; if not,
  // generate a usage prompt and exit:
  if(argc < 2) {
    cerr << "Usage: " << argv[0] << " <idc_file>" << endl;
    return 1;
  }

  // fetch the file name for the normalized DC IV curve:
  const char * name = argv[1];


  // Now we can set up the DC IV interpolation. file(), defined in
  // real_interp.h, loads in the data; quiet() silences complaints
  // about extrapolations.  See fakeiv.cc for a discussion of x() and
  // size().

  IDC.file(name).quiet();
  Vo = IDC.x(IDC.size()-1);     // max voltage in the table

  // Set the integrator control parameters:
  In.order = ORDER;
  In.abs_tolerance  = ABS_TOL;
  In.rel_tolerance = REL_TOL;

  // We'll create another interpolator to hold the calculated
  // Kramers-Kronig values; this way we can use the adaptive fill
  // algorithm to limit the number of points we need to calculate. See
  // fakeiv.cc for a description of how this works.

  interpolation ikk;  // the same as type interpolator<double> 
  ikk.left_slope(0);  // the endpoint slope of the transform for V == 0.

  // Don't set accuracies any tighter in the following, or you may see
  // convergence problems. Note that we generate the transform values
  // out to voltages double those in the DC IV data set.

  adaptive_fill(ikk, ikk_f, 0, 2*Vo, .0001, .001);

  // We're all done, except for displaying the results.

  // Set the output number format:
  cout << fixed << setprecision(18);

  // Let's print a header recording the DC IV file name used. Note
  // that we prefix the comment identifier to each header line.
  cout << comment << " Normalized SIS Kramers-Kronig IV characteristic curve" << endl;
  cout << comment << " The DC IV file for this data:  " << name << endl;
  cout << comment << endl;
  cout << comment << " V:         " << "\t" << "I:" << endl;

  // output the points actually used in the ikk interpolator:
  for (unsigned i = 0; i < ikk.size(); ++i)
    cout << ikk.x(i) << "\t" << ikk[i] << endl;

  return 0;
}
